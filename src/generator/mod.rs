//src/generator/mod.rs

use crate::parser::ApiMethod;

pub mod codegen;
pub mod versions;

use std::fmt::Write;
use std::fs;
use std::io;
use std::path::Path;

/// Generates a struct definition string from a type name, a description, and its fields.
pub fn generate_struct(type_name: &str, description: &str, fields: &str) -> String {
    let mut s = String::new();
    writeln!(s, "/// Response for the {} RPC call.", type_name).unwrap();
    writeln!(s, "{}", description).unwrap();
    writeln!(
        s,
        "#[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]"
    )
    .unwrap();
    writeln!(s, "pub struct {} {{", type_name).unwrap();
    writeln!(s, "{}", fields).unwrap();
    write!(s, "}}").unwrap();
    s
}

/// Implements the client macro for a given RPC method and version.
pub fn generate_client_macro(method: &ApiMethod, version: &str) -> String {
    codegen::generate_client_macro(method, version)
}

/// Generates the return type struct for a given RPC method.
pub fn generate_return_type(method: &ApiMethod) -> Option<String> {
    codegen::generate_return_type(method)
}

fn capitalize(s: &str) -> String {
    codegen::capitalize(s)
}

/// Generates the top-level `mod.rs` files (unchanged).
pub fn generate_mod_rs(output_dir: &str, versions: &[&str]) -> std::io::Result<()> {
    codegen::generate_mod_rs(output_dir, versions)
}

pub fn generate_type_conversion(method: &ApiMethod, _version: &str) -> Option<String> {
    if method
        .results
        .iter()
        .any(|r| r.type_.eq_ignore_ascii_case("none"))
    {
        return None;
    }
    let type_name = format!("{}Response", capitalize(&method.name));
    let model_type = format!("model::{}", type_name);
    Some(format!(
        r#"impl {} {{
    pub fn into_model(self) -> Result<{}, {}Error> {{
        Ok(())
    }}
}}"#,
        type_name, model_type, type_name
    ))
}

pub fn generate_client_mod_rs(versions: &[String], out_dir: &Path) -> io::Result<()> {
    generate_versioned_mod_rs(versions, out_dir, "client", "pub mod {};")
}

pub fn generate_types_mod_rs(versions: &[String], out_dir: &Path) -> io::Result<()> {
    generate_versioned_mod_rs(versions, out_dir, "types", "pub mod {}_types;")
}

/// Helper function to generate a mod.rs file declaring versioned modules.
fn generate_versioned_mod_rs(
    versions: &[String],
    out_dir: &Path,
    subdir: &str,
    mod_template: &str,
) -> io::Result<()> {
    use std::fmt::Write; // Import the Write trait for writeln!

    // Content for the mod.rs
    let mod_rs_content = versions.iter().fold(String::new(), |mut output, version| {
        // Use the provided template to format the module declaration
        let _ = writeln!(output, "{}", mod_template.replace("{}", version));
        output
    });

    let mod_path = out_dir.join(subdir).join("mod.rs");
    fs::create_dir_all(mod_path.parent().unwrap())?;
    fs::write(&mod_path, mod_rs_content)?;
    Ok(())
}

/// Generates the top-level `src/client/mod.rs` file that declares all versioned client modules.
pub fn generate_top_level_client_mod(versions: &[String], src_dir: &Path) -> io::Result<()> {
    use std::fmt::Write; // Import the Write trait for writeln!

    let mut client_mod_rs = String::new();
    writeln!(
        client_mod_rs,
        "// Auto-generated client module declarations."
    )
    .map_err(|e| io::Error::new(io::ErrorKind::Other, e))?;
    writeln!(client_mod_rs, "// Do not edit this file manually.")
        .map_err(|e| io::Error::new(io::ErrorKind::Other, e))?;
    writeln!(client_mod_rs).map_err(|e| io::Error::new(io::ErrorKind::Other, e))?; // Add a blank line

    for version in versions {
        writeln!(client_mod_rs, "pub mod {}", version)
            .map_err(|e| io::Error::new(io::ErrorKind::Other, e))?;
    }
    writeln!(client_mod_rs).map_err(|e| io::Error::new(io::ErrorKind::Other, e))?; // Add a blank line

    for version in versions {
        writeln!(client_mod_rs, "pub use self::{}::*;", version)
            .map_err(|e| io::Error::new(io::ErrorKind::Other, e))?;
    }

    let client_mod_path = src_dir.join("client").join("mod.rs");
    fs::create_dir_all(client_mod_path.parent().unwrap())?;
    fs::write(&client_mod_path, client_mod_rs)?;
    Ok(())
}

/// Generates the top-level `src/types/mod.rs` file that declares all versioned types modules.
pub fn generate_top_level_types_mod(versions: &[String], src_dir: &Path) -> io::Result<()> {
    use std::fmt::Write; // Import the Write trait for writeln!

    let mut types_mod_rs = String::new();
    writeln!(types_mod_rs, "// Auto-generated types module declarations.")
        .map_err(|e| io::Error::new(io::ErrorKind::Other, e))?;
    writeln!(types_mod_rs, "// Do not edit this file manually.")
        .map_err(|e| io::Error::new(io::ErrorKind::Other, e))?;
    writeln!(types_mod_rs).map_err(|e| io::Error::new(io::ErrorKind::Other, e))?; // Add a blank line

    for version in versions {
        writeln!(types_mod_rs, "pub mod {}_types;", version)
            .map_err(|e| io::Error::new(io::ErrorKind::Other, e))?;
    }
    writeln!(types_mod_rs).map_err(|e| io::Error::new(io::ErrorKind::Other, e))?; // Add a blank line

    for version in versions {
        writeln!(types_mod_rs, "pub use self::{}_types::*;", version)
            .map_err(|e| io::Error::new(io::ErrorKind::Other, e))?;
    }

    let types_mod_path = src_dir.join("types").join("mod.rs");
    fs::create_dir_all(types_mod_path.parent().unwrap())?;
    fs::write(&types_mod_path, types_mod_rs)?;
    Ok(())
}

pub use crate::generator::codegen::generate_version_code;
