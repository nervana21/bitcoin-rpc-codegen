use std::{env, fs, path::PathBuf};

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Usage: cargo run -p codegen --bin update_wallet_methods -- /abs/path/to/api_v29.json
    let json_path = env::args()
        .nth(1)
        .map(PathBuf::from)
        .ok_or("Usage: update_wallet_methods /absolute/path/to/api_vXX.json")?;

    let json = fs::read_to_string(&json_path)?;
    let v: serde_json::Value = serde_json::from_str(&json)?;

    let rpcs = v
        .get("rpcs")
        .and_then(|r| r.as_object())
        .ok_or("api JSON missing 'rpcs' object")?;

    let mut wallet_methods: Vec<String> = rpcs
        .iter()
        .filter_map(|(name, obj)| {
            obj.get("category")
                .and_then(|c| c.as_str())
                .is_some_and(|c| c == "wallet")
                .then(|| name.clone())
        })
        .collect();

    wallet_methods.sort_unstable();

    let methods_body = wallet_methods
        .iter()
        .map(|m| format!("    \"{m}\","))
        .collect::<Vec<_>>()
        .join("\n");

    let contents = format!(
        "// @generated by update_wallet_methods; do not edit by hand

/// List of Bitcoin Core RPC methods that require a wallet to be loaded
pub const WALLET_METHODS: &[&str] = &[
{methods_body}
];
"
    );

    // Write to codegen/src/wallet_methods.rs
    let out_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .join("src")
        .join("wallet_methods.rs");
    fs::write(&out_path, contents)?;
    eprintln!(
        "Updated {} methods in {}",
        wallet_methods.len(),
        out_path.display()
    );
    Ok(())
}
