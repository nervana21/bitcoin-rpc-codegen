//! # ModuleGenerator – automated namespace scaffolding
//!
//! This crate contains **`ModuleGenerator`**, a tiny utility whose sole job is to
//! _write the `mod.rs` glue files you would otherwise maintain by hand_.
//!
//! Given a list of Bitcoin Core RPC schema versions—e.g. `["V28", "V29", "latest"]`—
//! and an output directory that already holds code‑generated sources like
//!
//! ```text
//! client/<version>/*.rs
//! types/<version>_types/*.rs
//! ```
//!
//! the generator creates **all** of the Rust namespaces so that downstream code
//! can simply do:
//!
//! ```rust, ignore
//! use generated::client::*; // re‑exports v28, v29, latest…
//! use generated::types::*;  // ditto for all *_types
//! ```
//!
//! Concretely it writes:
//!
//! 1. `client/<version>/mod.rs` – declares the per‑version RPC client modules  
//! 2. `types/<version>_types/mod.rs` – declares the per‑version type modules  
//! 3. `client/mod.rs` **and** `types/mod.rs` – re‑export every version so callers
//!    don’t need to spell them out individually
//!
//! In short, **`ModuleGenerator` is a “namespace builder”**: it fabricates the
//! entire module hierarchy that stitches together code‑generated RPC clients and
//! type definitions, eliminating the need to touch `mod.rs` files ever again.

use rpc_api::Version;
use std::{
    fs, io,
    path::{Path, PathBuf},
};

/// **`ModuleGenerator`**  
/// Builds the *module scaffolding* that glues all the code‑generated files
/// together – essentially every `mod.rs` you’d otherwise write by hand.
///
/// * `versions` is a list like `["v28","v29","latest"]` that you want to
///   appear as sub‑modules (one folder per RPC‑schema version).
/// * `out_dir` is the root folder that already contains `client/`,
///   `types/`, etc. (e.g. `client/src/generated`).
pub struct ModuleGenerator {
    versions: Vec<Version>,
    out_dir: PathBuf,
}

impl ModuleGenerator {
    /// Create a new generator for the given `versions` and output directory.
    pub fn new(versions: Vec<Version>, out_dir: PathBuf) -> Self {
        Self { versions, out_dir }
    }

    /// Convenience orchestrator – call this once and you'll get **all**
    /// `mod.rs` files written:
    /// 1. `client/<version>/mod.rs`
    /// 2. `types/<version>_types/mod.rs`
    /// 3. top‑level re‑export files (`client/mod.rs`, `types/mod.rs`)
    pub fn generate_all(&self) -> io::Result<()> {
        self.generate_types_mod_rs()?;
        self.generate_top_level_modules()?;
        Ok(())
    }

    /// Writes _one_ `mod.rs` that lives in  
    /// `…/types/mod.rs` and declares `pub mod v28_types; pub mod v29_types; …`.
    pub fn generate_types_mod_rs(&self) -> io::Result<()> {
        generate_versioned_mod_rs(&self.versions, &self.out_dir, "types", "pub mod {}_types;")
    }

    /// Creates the two *top‑level* module files that simply `pub use`
    /// every version so downstream crates can do `use generated::client::*`.
    pub fn generate_top_level_modules(&self) -> io::Result<()> {
        self.generate_top_level_client_mod()?;
        self.generate_top_level_types_mod()?;
        Ok(())
    }

    fn generate_top_level_client_mod(&self) -> io::Result<()> {
        use std::fmt::Write;

        let mut client_mod_rs = String::new();
        writeln!(
            client_mod_rs,
            "// Auto-generated client module declarations."
        )
        .map_err(io::Error::other)?;
        writeln!(client_mod_rs, "// Do not edit this file manually.").map_err(io::Error::other)?;
        writeln!(client_mod_rs).map_err(io::Error::other)?;

        for version in &self.versions {
            writeln!(client_mod_rs, "pub mod {};", version.as_str()).map_err(io::Error::other)?;
        }
        writeln!(client_mod_rs).map_err(io::Error::other)?;

        for version in &self.versions {
            writeln!(client_mod_rs, "pub use self::{}::*;", version.as_str())
                .map_err(io::Error::other)?;
        }

        let client_mod_path = self.out_dir.join("client").join("mod.rs");
        fs::create_dir_all(client_mod_path.parent().unwrap())?;
        fs::write(&client_mod_path, client_mod_rs)?;
        Ok(())
    }

    fn generate_top_level_types_mod(&self) -> io::Result<()> {
        use std::fmt::Write;

        let mut types_mod_rs = String::new();
        writeln!(types_mod_rs, "// Auto-generated types module declarations.")
            .map_err(io::Error::other)?;
        writeln!(types_mod_rs, "// Do not edit this file manually.").map_err(io::Error::other)?;
        writeln!(types_mod_rs).map_err(io::Error::other)?;

        for version in &self.versions {
            writeln!(
                types_mod_rs,
                "pub mod {}_types;",
                version.as_str_lowercase()
            )
            .map_err(io::Error::other)?;
        }
        writeln!(types_mod_rs).map_err(io::Error::other)?;

        for version in &self.versions {
            writeln!(
                types_mod_rs,
                "pub use self::{}_types::*;",
                version.as_str_lowercase()
            )
            .map_err(io::Error::other)?;
        }

        let types_mod_path = self.out_dir.join("types").join("mod.rs");
        fs::create_dir_all(types_mod_path.parent().unwrap())?;
        fs::write(&types_mod_path, types_mod_rs)?;
        Ok(())
    }
}

/// Helper function to generate a mod.rs file declaring versioned modules.
fn generate_versioned_mod_rs(
    versions: &[Version],
    out_dir: &Path,
    subdir: &str,
    mod_template: &str,
) -> io::Result<()> {
    use std::fmt::Write;

    let mod_rs_content = versions.iter().fold(String::new(), |mut output, version| {
        let _ = writeln!(output, "{}", mod_template.replace("{}", version.as_str()));
        output
    });

    let mod_path = out_dir.join(subdir).join("mod.rs");
    fs::create_dir_all(mod_path.parent().unwrap())?;
    fs::write(&mod_path, mod_rs_content)?;
    Ok(())
}
