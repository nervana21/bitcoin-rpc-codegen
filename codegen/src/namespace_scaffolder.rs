//! # ModuleGenerator – automated namespace scaffolding
//!
//! This crate contains **`ModuleGenerator`**, a tiny utility whose sole job is to
//! _write the `mod.rs` glue files you would otherwise maintain by hand_.
//!
//! Given a list of Bitcoin Core RPC schema versions—e.g. `["V28", "V29", "latest"]`—
//! and an output directory that already holds code‑generated sources like
//!
//! ```text
//! responses/<version>_types/*.rs
//! ```
//!
//! the generator creates **all** of the Rust namespaces so that downstream code
//! can simply do:
//!
//! ```rust, ignore
//! use generated::responses::*;  // re‑exports v28_types, v29_types, latest_types…
//! ```
//!
//! Concretely it writes:
//!
//! 1. `responses/<version>_types/mod.rs` – declares the per‑version type modules  
//! 2. `responses/mod.rs` – re‑export every version so callers
//! 1. `client/<version>/mod.rs` – declares the per‑version RPC client modules  
//! 2. `responses/<version>_types/mod.rs` – declares the per‑version type modules  
//! 3. `client/mod.rs` **and** `responses/mod.rs` – re‑export every version so callers
//!    don’t need to spell them out individually
//!
//! In short, **`ModuleGenerator` is a “namespace builder”**: it fabricates the
//! entire module hierarchy that stitches together code‑generated type definitions,
//! type definitions, eliminating the need to touch `mod.rs` files ever again.

use std::path::{Path, PathBuf};
use std::{fs, io};

use crate::Version;

/// **`ModuleGenerator`**  
/// Builds the *module scaffolding* that glues all the code‑generated files
/// together – essentially every `mod.rs` you’d otherwise write by hand.
///
/// * `versions` is a list like `["v28","v29","latest"]` that you want to
///   appear as sub‑modules (one folder per RPC‑schema version).
/// * `out_dir` is the root folder that already contains `client/`,
///   `types/`, etc. (e.g. `client/src/generated`).
pub struct ModuleGenerator {
    versions: Vec<Version>,
    out_dir: PathBuf,
}

impl ModuleGenerator {
    /// Create a new generator for the given `versions` and output directory.
    pub fn new(versions: Vec<Version>, out_dir: PathBuf) -> Self { Self { versions, out_dir } }

    /// Convenience orchestrator – call this once and you'll get **all**
    /// `mod.rs` files written:
    /// 1. `responses/<version>_responses/mod.rs`
    /// 2. top‑level re‑export files (`responses/mod.rs`)
    pub fn generate_all(&self) -> io::Result<()> {
        self.generate_responses_mod_rs()?;
        self.generate_top_level_responses_mod()?;
        Ok(())
    }

    /// Writes _one_ `mod.rs` that lives in  
    /// `…/responses/mod.rs` and declares `pub mod v28_responses; pub mod v29_responses; …`.
    pub fn generate_responses_mod_rs(&self) -> io::Result<()> {
        generate_versioned_mod_rs(
            &self.versions,
            &self.out_dir,
            "responses",
            "pub mod {}_responses;",
        )
    }

    /// Creates the top‑level responses module file that declares `pub mod` for each version
    /// and then `pub use` every version so downstream crates can do `use generated::responses::*`.
    fn generate_top_level_responses_mod(&self) -> io::Result<()> {
        use std::fmt::Write;

        let mut types_mod_rs = String::new();
        writeln!(types_mod_rs, "// Auto-generated types module declarations.")
            .map_err(io::Error::other)?;
        writeln!(types_mod_rs, "// Do not edit this file manually.").map_err(io::Error::other)?;
        writeln!(types_mod_rs).map_err(io::Error::other)?;

        for version in &self.versions {
            writeln!(types_mod_rs, "pub mod {}_responses;", version.as_module_name())
                .map_err(io::Error::other)?;
        }
        writeln!(types_mod_rs).map_err(io::Error::other)?;

        for version in &self.versions {
            writeln!(types_mod_rs, "pub use self::{}_responses::*;", version.as_module_name())
                .map_err(io::Error::other)?;
        }

        let types_mod_path = self.out_dir.join("responses").join("mod.rs");
        fs::create_dir_all(types_mod_path.parent().unwrap())?;
        fs::write(&types_mod_path, types_mod_rs)?;
        Ok(())
    }
}

/// Helper function to generate a mod.rs file declaring versioned modules.
fn generate_versioned_mod_rs(
    versions: &[Version],
    out_dir: &Path,
    subdir: &str,
    mod_template: &str,
) -> io::Result<()> {
    use std::fmt::Write;

    let mod_rs_content = versions.iter().fold(String::new(), |mut output, version| {
        let _ = writeln!(output, "{}", mod_template.replace("{}", &version.as_module_name()));
        output
    });

    let mod_path = out_dir.join(subdir).join("mod.rs");
    fs::create_dir_all(mod_path.parent().unwrap())?;
    fs::write(&mod_path, mod_rs_content)?;
    Ok(())
}
